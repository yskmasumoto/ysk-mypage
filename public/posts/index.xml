<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ysk-mypage</title>
    <link>https://yskmasumoto.github.io/posts/</link>
    <description>Recent content in Posts on ysk-mypage</description>
    <generator>Hugo</generator>
    <language>ja-jp</language>
    <lastBuildDate>Thu, 25 Jul 2024 12:34:12 +0900</lastBuildDate>
    <atom:link href="https://yskmasumoto.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ltkai</title>
      <link>https://yskmasumoto.github.io/posts/ltkai/</link>
      <pubDate>Thu, 25 Jul 2024 12:34:12 +0900</pubDate>
      <guid>https://yskmasumoto.github.io/posts/ltkai/</guid>
      <description>LT会で発表しました。</description>
    </item>
    <item>
      <title>WASMのアクセス制限</title>
      <link>https://yskmasumoto.github.io/posts/wasm-memo/</link>
      <pubDate>Thu, 25 Jul 2024 11:30:18 +0900</pubDate>
      <guid>https://yskmasumoto.github.io/posts/wasm-memo/</guid>
      <description>WASMがファイルアクセス、ネットワークアクセス、DOMアクセスなどを直接実行できない理由についての簡単なまとめ&#xA;1. WASMの設計思想 高速で安全な実行環境の提供が目的 限定的な機能セットを持つ仮想マシンとしての実装 2. サンドボックス化 ホスト環境によるサンドボックス内での実行 外部環境からの隔離 直接的なシステムリソースへのアクセス制限 3. セキュリティ考慮 直接アクセスによる潜在的セキュリティリスクの回避 悪意のあるコードからの重要データの保護 不正操作の防止 4. プラットフォーム独立性 様々な環境での動作を目指す設計 特定システムに依存する機能の直接サポート回避 5. ホスト環境への依存 ホスト環境を通じた機能アクセス 必要に応じたアクセス権限の提供 6. Web APIとの統合 ブラウザ環境におけるJavaScriptを介したWeb APIアクセス WASMモジュールからの直接API呼び出し不可 7. WASI 非ブラウザ環境での標準化されたシステムインターフェース ホスト環境による制御 8. 明示的な権限付与 ホスト環境によるWASMモジュールへの明示的権限付与 最小権限原則の適用 9. メモリ分離 WASMモジュール独自のメモリ空間 ホストシステムメモリへの直接アクセス不可 メモリ関連攻撃やデータ漏洩リスクの軽減 10. パフォーマンスの最適化 直接的システムアクセスの制限によるコード実行の最適化 高速処理の実現 所感 ファイルI/Oに依存しないロジックに対して特に有効そう 設計思想やシステム的に、WASMモジュール上でファイルI/Oを行うのは悪手に見える やろうと思えばJavascript Bridgeなどを使えば可能 RustやGo, Cで試してみたい </description>
    </item>
    <item>
      <title>ELB/ECS構成のAPIトラブルシューティング要約</title>
      <link>https://yskmasumoto.github.io/posts/ecs503error-troubleshooting/</link>
      <pubDate>Tue, 23 Jul 2024 21:22:57 +0900</pubDate>
      <guid>https://yskmasumoto.github.io/posts/ecs503error-troubleshooting/</guid>
      <description>筆者がAIにした質問内容 curlでELB, ECS構成のAPIを呼び出すと503エラーが返ってくる問題の解決方法 ELBのポート番号の確認方法 DockerfileのCMD部分とELBの設定の不一致に関する質問 ECSのタスク定義のCloudFormationに関する質問 uvicornのポート変更後もcurlで503エラーが発生する問題の解決方法 解決プロセス ECSタスクの状態確認（稼働状況、エラーログ、ヘルスチェック設定） Dockerfileの確認と改善提案 ELBの設定確認（ポート番号、リスナー設定） ECSタスク定義の確認とDockerfileとの整合性チェック ポートマッピングの修正（8000から80へ） セキュリティグループ、ネットワーク設定の確認 アプリケーションログとELBアクセスログの確認 ロードバランサーのリスナールール優先度の確認 原因 DockerfileとECSタスク定義のポート設定の不一致（8000 vs 80） ロードバランサーのリスナールール優先度設定ミス（v1とv2のルーティング） 再発防止策 Dockerfileとタスク定義の一貫性確保 デプロイ前の設定チェックリストの作成と使用 自動テストの導入（ルーティングチェック等） ブルー/グリーンデプロイメント戦略の採用 インフラストラクチャのコード化（IaC） 定期的な設定レビューの実施 問題と解決策の文書化とチーム内共有 関連キーワード ELB (Elastic Load Balancer) ECS (Elastic Container Service) Docker uvicorn CloudFormation ポートマッピング セキュリティグループ ヘルスチェック リスナールール ロードバランサー優先度設定 Continuous Integration/Continuous Deployment (CI/CD) Infrastructure as Code (IaC) ブルー/グリーンデプロイメント </description>
    </item>
    <item>
      <title>AWS Lambda Powertools Logger TypeErrorの解決</title>
      <link>https://yskmasumoto.github.io/posts/aws-powertools-logger-tips/</link>
      <pubDate>Mon, 22 Jul 2024 21:29:04 +0900</pubDate>
      <guid>https://yskmasumoto.github.io/posts/aws-powertools-logger-tips/</guid>
      <description>AWS Lambda Powertools Logger TypeErrorの解決 エラー内容 TypeError: aws_lambda_powertools.logging.logger.Logger._init_logger() got multiple values for keyword argument &amp;#39;log_level&amp;#39; エラーの原因 このエラーは通常、Loggerクラスのインスタンス化時にlog_levelパラメータが重複して指定されている場合に発生します。以下の状況で起こる可能性があります：&#xA;コード内で複数回Loggerインスタンスを作成し、それぞれでlog_levelを指定している。 環境変数LOG_LEVELが設定されている状態で、コード内でもlog_levelを指定している。 デコレータ@logger.inject_lambda_contextでlog_levelを指定し、同時にLoggerインスタンス作成時にも指定している。 解決方法 1. Loggerインスタンスの一元管理 アプリケーション全体で単一のLoggerインスタンスを使用します。 可能な限り、Loggerインスタンスを作成する場所を1箇所に限定します。 from aws_lambda_powertools import Logger logger = Logger() # 他のモジュールやクラスでこのloggerを再利用 2. 環境変数の活用 LOG_LEVEL環境変数を使用してログレベルを制御します。 コード内でlog_levelを指定する代わりに、環境変数に依存します。 # 環境変数 LOG_LEVEL を設定し、コードでは指定しない logger = Logger() 3. デコレータの適切な使用 @logger.inject_lambda_contextデコレータを使用する場合、デコレータ内でlog_levelを指定せず、Loggerインスタンス化時にのみ指定します。 logger = Logger(log_level=&amp;#34;INFO&amp;#34;) @logger.inject_lambda_context(log_event=True) def handler(event, context): logger.info(&amp;#34;This is an info message&amp;#34;) 4. 依存性注入パターンの採用 Loggerインスタンスを外部から注入できるようにクラスを設計します。 class SQS: def __init__(self, queue_url: str, logger: Logger = None): self.</description>
    </item>
  </channel>
</rss>
